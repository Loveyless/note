import{_ as e,c as t,o,ag as l}from"./chunks/framework.M6oQTw7-.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/排序/0.index.md","filePath":"algorithm/排序/0.index.md","lastUpdated":1669459159000}'),i={name:"algorithm/排序/0.index.md"};function r(p,a,n,d,s,h){return o(),t("div",null,[...a[0]||(a[0]=[l('<h2 id="如何分析排序算法" tabindex="-1">如何分析排序算法？ <a class="header-anchor" href="#如何分析排序算法" aria-label="Permalink to &quot;如何分析排序算法？&quot;">​</a></h2><ol><li><p>最好情况、最坏情况、平均情况时间复杂度</p></li><li><p>时间复杂度的系数、常数 、低阶</p></li><li><p>比较次数和交换（或移动）次数</p></li></ol><h2 id="排序算法的内存消耗" tabindex="-1">排序算法的内存消耗 <a class="header-anchor" href="#排序算法的内存消耗" aria-label="Permalink to &quot;排序算法的内存消耗&quot;">​</a></h2><p>内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p><h2 id="排序算法的稳定性" tabindex="-1">排序算法的稳定性 <a class="header-anchor" href="#排序算法的稳定性" aria-label="Permalink to &quot;排序算法的稳定性&quot;">​</a></h2><p>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><blockquote><p>在排序的时候都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。比如按照订单的金额来排序，金额相同的订单，我们希望按照下单时间先后来排序，这样就需要稳定排序算法来保证金额相同的订单，下单时间靠前的在前面。</p></blockquote><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><ol><li><p>冒泡排序</p><p>是原地排序，因为值涉及相邻数据的交换操作</p><p>是稳定的排序，因为相邻元素大小相等时不会交换所以顺序不会改变</p><p>时间复杂度，假设要从头到尾都发生了交换那么复杂度为 O(n2次)，如果数组已经有序则为 O(n)</p></li><li><p>插入排序</p><p>是原地排序，不需要额外的存储空间</p><p>是稳定的排序，对于相同的元素，可以将后面出现的插入前面元素的后面</p><p>复杂度O(n2次)</p></li></ol>',9)])])}const m=e(i,[["render",r]]);export{_ as __pageData,m as default};
